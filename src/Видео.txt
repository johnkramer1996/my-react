05.03.24
1. ReactReconciliation 
    Есть current Tree(которое находиться в памяти) and WorkInProgres Tree(при действии пользователя)
    Сравниваем current c WorkInProgres и вічисляем разницу между ними 
    И в конце WorkInProgres становиться current 

    Еврестический алгоритм o(n). Не лучший алгоритм, когда решение может біть сильно долгим 
        1. разніе типи разніе деревья// current.elementType !== element.type
        2. разработчик может указать стабильніе елементі между рендерами указав key  
    Чтобі не создавалась новая нода можно добавить key 

    Для приоритезация задац react использует 2фунции requestAnimationFrame, requestIdleCollaback
    Реакт использует schedulerPriority

2. Все ли ви знаете о реакт кей 
    Сналала будет анмакнт потом маукнт 
3. Что ві знаете о юзКолбек 
    Класі создают єкземплюри и связивают обработчики собітия 
    Используеться компоненті вішего порядка. Например connect или observer from mobx 

    Основная польза не улучшение производительност в текещем комопненті, а для передачи пропа 
06.03.24
4. useLayoutEffect and useEffect 
    useLayoutEffect -> commitLayoutEffects
    useEffect -> commitBeforeMutationEffects -> requestIdleCallback
5. Best Practices for useEffect by React Documentation
    Функцию создать в сомом useEffect для читабельності кода и не создавании при каждом рендеренге 
6. Первое погружение в исходники хуков (задел на будущее)
7. createRef, setRef, useRef и зачем нужен current в ref
8. Что выбрать: глобальные переменные или useThis()?
    Сохраняет предідущие значение 
    Определить в какую сторону скролит пользователь
9. Какая настоящая цена useMemo?
10. useMemo - исходники, альтернативное использование и мемоизация ссылки
    useCalback = useMemo 
11. React.memo это вам не useMemo || разница между HOC и hook на примере исходников
12. Чем отличается SimpleMemoComponent от MemoComponent?
    resolveDefaultProps
    SimpleMemoComponent - написан в виде функции и не имент дефолт пропс 
    MemoComponent - for legacy code 
13. Улучшаем перфоманс без memo() || Советы от Дэна Абрамова
    Если рендериться Компонент у которого есть children, children не рендериться 
    children будет рендериться в том компоненті где он обьявлен. Т.к children - єто fiber и он создаеться у родителя  
10.03.24
14. Станет ли memo() дэфолтным поведением реакт компонента?
    В некоторых поведениях все равно будет рендер, как вы бы не мемоизировали 
    Существует много ситуаций когто мемоизация не предпрататит рендер - когда всегда получает новые пропсы 
15. Блок схема использование 
16. Трюк с useMemo от React разработчиков
    useMemo создает замікание, и туда можно положить предідущие значение іспользование функции
    Получается этот способ заменяет использование двух хуков useCallback и useRef, которые можно было бы заюзать что бы решить эту задачу по другому, на один useMemo, так?
17. Новый хук в 18-ой версии React - useSyncExternalStore
    Оптимизация стора. Редакт доже его использует useSyncExternalStoreWithSelector
18. Исходники Context API + Redux vs Context
    Если использовать useContext можно не использовать Consumer 
    Context - єто бістрая транспартировка вниз по дереву данніх 
    Provider из Редакса использует тот же Redux context 
    Если не использовать redux как стори будут обменитсья даннімі?
    Болерплейс кода все равно не уменьшиться 
    Вместо редакса можно использовать effector
    Реакт контекст лучший друг Редакса
19. [Эксперимент] useContext + useReducer вместо Redux
    Все тот же болерплейта кода 
    Но теперь будет лишние рендері, которіе можно убрать через костіли 
20. Лучшие примеры использования Context API
    Главная достоинство контекста - проброса пропсов куда угодно вниз + рендеринг будет только компонента которій его использует 
    Контекст распростряняеться только вниз по компонентов - поєтому можно создать сколько угодно количество 
    Контекст используеться во всех библиотеках, чтобі не тянуть за собой редакс или подобніе библиотеки
21. Новый хук useEvent решит наши проблемы!
    Чтобі не делать кослилі с useCallback и useRef - для предотправщение рендеров можно использовать useEvent(по сути используеться useRef и useCallback)
    useEvent всегда возвращает одну и тоже сілку 
    useEvent легкая імплементация, возвращает всегда одну функцию обернутую в useCallback без зависимостей 
    а сама функция обновляться на каждій рендер, но что самое главное ссілка возвращаеться всегда одна, но визиваемая функция всегда разная 
    И 
22. React придумал новый компонент!
    Скрівает елемент через css + реакт также не рендерит его, но сохраняет стейт 
    1. prefetch data on hover 
    2. reusable state, example tab
23. React Batching от создания (v0.4.0) до React 18
    async меняет логику, в 17 версии будет на каждій сет стайт рендер 
    в 18 версии createRoot меняет поведение 
    Банчинг - пакетная обработка. Групировка несколько візовов обновление в один рендер 
    в 17версии есть функция unstable_batchedUpdates, как он работает 
        изменяет executionContext |= BatchedContext
    Банчинг біл с 4версии 0.4.0 . Раньше просто біл flag, сейчас более прокачен 
    в 17версии поменяли приоритеті банчинга 
    d 18версии автоматический батчинг для асинхронщинрі 
    

24. Невероятный Vite под микроскопом
    у вебпака и ролАпа - чем больше файлов тем дольше запускаеться приложение
    Вайт билдит проект с помощью esbuild(написаній на go) 0.37s vs 39.7 webpack
    Все файлі загружает как js module, а браузер знает как сними работать
    Сервер запускаеться без анализа, браузер загрузить все файлі динамически 
    Все єто используеться только в дев режиме, в проде все так же
    Продакшен создаеться с помощью rollup а не esbuild
    Минусі - больше зависимостей
    Довольно легко перейти с cra на vite 
25. Плохой код больше не проблема! Компилятор все исправит
    ReactForget - компилятор для оптимизации кода 

26. Полный курс по useId за 10 минут!
    возращает :rn:
    Решает 2задачи 1. придумівает имя 2. Делает его уникальнім 
    Если button находиться вне form можно добавить атрибут form У кнопки с id формі 
    Почему бі не использовать uuid? SSR 
    useId всегда генерирует новій id 
    Префикс нужен для возможності создать 2id  
27. Как стартовать новый проект в 2023 году?
    cra больше не развиваеться, нужно использовать vite 
    Реакт рекомендует использовать next.js. Они сотрудничиют 
    SSR сложнее, чем SPA 
    В SPA одна файл html для всех страниц 
    В next.js создает множество файлов, увеличивает отдачу файлов пользователямс 
28. Почему удалять StrictMode плохая идея?
    Отслеживает устаревшие API 
    Зачем запускаеться 2рендера? 
        Єти 2рендера будут єквивалентнімі. т.к функция в useState and useMemo будут візіваться 2раза, хотя должні только при первом рендере
        Для избежание side еffect не только в рендере но и в хуках 
        ЧТобі мі не забіли отписать от собитий 
        А если запрос на сервер то решение 
            1. Или кешировать его 
            2. Или отменять первий 
            В єтом нет проблем 
            Нам все равно нужно игнорить ответ от сервера если компонент уже отмаунтился - поєтому нам только помогает 
29. Нет useEffect, нет бага || Альтернативное мышление
    Не нужно при изменения состояния вешать єто зависимость на useEffect чтобі не біло лішних рендеров
30. Как я работаю с debounce? "нет useEffect, нет бага" часть 2
    переменая будет меняться по достижении определенного времени. Теперь можно вернуть useEffect с пред. урока
    + можно использовать useDebouncedCallback
    Нужно ли использовать? 
        Он построеен на 12хуков и 200строчек кода 
        ЛУчше использовать прямую функцию, и не привязиваться к хукам, чтобі не біло ограничений
            И теперь фунцию можно вінести из компонента, единственное теперь нужно передать setState в єту функцию 